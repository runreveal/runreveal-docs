(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9260],{28382:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/detections/writing-a-detection",function(){return t(28558)}])},28558:function(e,n,t){"use strict";t.r(n),t.d(n,{useTOC:function(){return d}});var i=t(85893),a=t(37812),r=t(84854),s=t(79299);function d(e){return[{value:"Parameters",id:"parameters",depth:2},{value:"Always Parameters",id:"always-parameters",depth:3},{value:"Defining your own parameters",id:"defining-your-own-parameters",depth:3}]}n.default=(0,a.c)(function(e){let{toc:n=d(e)}=e,t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",span:"span",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{children:"Writing a SQL detection"}),"\n",(0,i.jsx)(t.p,{children:"RunReveal detections are queries that run on a schedule. Currently, SQL is the only supported\nlanguage for detections, althrough pql is planned to be supported soon (and isn’t difficult\nto translate to valid clickhouse SQL)."}),"\n",(0,i.jsx)(t.h2,{id:n[0].id,children:n[0].value}),"\n",(0,i.jsxs)(t.p,{children:["When using the explore page and creating a detection you’ll notice that the generated query\nhas ",(0,i.jsx)(t.code,{children:"{from:DateTime}"})," and ",(0,i.jsx)(t.code,{children:"{to:DateTime}"})," in it. These are parameters. Parameters are a clickhouse\nspecific syntax that you can read more about on their docs:"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://clickhouse.com/docs/en/sql-reference/syntax#defining-and-using-query-parameters",children:"https://clickhouse.com/docs/en/sql-reference/syntax#defining-and-using-query-parameters"})}),"\n",(0,i.jsx)(t.h3,{id:n[1].id,children:n[1].value}),"\n",(0,i.jsx)(t.p,{children:"RunReveal passes the following parameters to each of your detections every time they run to help with windowing your data."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"from"})," - The start-time of the current data window."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"to"})," - The end-time of the current data window."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["By including these parameters in your detection, you can support effective windowing, without needing to worry\nabout lost data, delayed data, etc. It’s best to include in your where clause a check that the ",(0,i.jsx)(t.code,{children:"receivedAt"})," time\nis greater than or equal to the from time, and less than the to time. By using the ",(0,i.jsx)(t.code,{children:"receivedAt"})," time\nfrom the RunReveal log schema, you automatically handle situations where your services generate logs that\narrive on a delay (for example, cloudtrail)."]}),"\n",(0,i.jsx)(t.p,{children:"For example:"}),"\n",(0,i.jsx)(t.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsxs)(t.code,{children:[(0,i.jsx)(t.span,{children:(0,i.jsx)(t.span,{children:"SELECT "})}),"\n",(0,i.jsx)(t.span,{children:(0,i.jsx)(t.span,{children:"    *"})}),"\n",(0,i.jsx)(t.span,{children:(0,i.jsx)(t.span,{children:"FROM aws_cloudtrail_logs"})}),"\n",(0,i.jsx)(t.span,{children:(0,i.jsx)(t.span,{children:"WHERE"})}),"\n",(0,i.jsx)(t.span,{children:(0,i.jsx)(t.span,{children:"    eventName='Decrypt' AND"})}),"\n",(0,i.jsx)(t.span,{children:(0,i.jsx)(t.span,{children:"    receivedAt >= {from:DateTime} AND"})}),"\n",(0,i.jsx)(t.span,{children:(0,i.jsx)(t.span,{children:"    receivedAt < {to:DateTime}"})})]})}),"\n",(0,i.jsx)(t.h3,{id:n[2].id,children:n[2].value}),"\n",(0,i.jsx)(t.p,{children:"Parameters can also be defined as well, for useful omissions, inclusions, etc. And you’ll notice several of RunReveal’s\npre-created detections contain parameters that can be used like this. For example, to create a detection and exclude your\nlist of office IP addresses, you can create a SQL detection like this:"}),"\n",(0,i.jsx)(t.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsxs)(t.code,{children:[(0,i.jsx)(t.span,{children:(0,i.jsx)(t.span,{children:"SELECT * from runreveal_logs"})}),"\n",(0,i.jsx)(t.span,{children:(0,i.jsx)(t.span,{children:"WHERE eventName = 'thing-that-should-only-be-done-in-office'"})}),"\n",(0,i.jsx)(t.span,{children:(0,i.jsx)(t.span,{children:"AND srcIP not in ({officeIPs:Array(String)})"})})]})}),"\n",(0,i.jsxs)(t.p,{children:["With the ",(0,i.jsx)(t.code,{children:"officeIPs"})," parameter defined like so to include each of your office IPs."]}),"\n",(0,i.jsx)(t.pre,{tabIndex:"0","data-language":"plaintext","data-word-wrap":"",children:(0,i.jsx)(t.code,{children:(0,i.jsx)(t.span,{children:(0,i.jsx)(t.span,{children:"1.2.3.4, 2.3.4.5, 4.3.2.1"})})})})]})},"/detections/writing-a-detection",{filePath:"pages/detections/writing-a-detection.mdx",timestamp:1751413272e3,pageMap:r.v,frontMatter:{title:"Writing SQL Detections - Query Parameters and Time Windowing",description:"Learn how to write SQL detections in RunReveal with proper parameters, time windowing, and ClickHouse syntax. Create effective scheduled security queries."},title:"Writing SQL Detections - Query Parameters and Time Windowing"},"undefined"==typeof RemoteContent?d:RemoteContent.useTOC)}},function(e){e.O(0,[7812,4854,2888,9774,179],function(){return e(e.s=28382)}),_N_E=e.O()}]);